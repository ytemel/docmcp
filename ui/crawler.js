import axios from 'axios';
import fs from 'fs/promises';
import path from 'path';
import dotenv from 'dotenv';

// Load environment variables
dotenv.config();

// Configuration
const FIRECRAWL_API_KEY = process.env.FIRECRAWL_API_KEY;
const FIRECRAWL_BASE_URL = 'https://api.firecrawl.dev/v1';

// Hardcoded documentation URL for testing
const DOCUMENTATION_URL = 'https://docs.storyly.io/docs/android-initial-sdk-setup';

// Output configuration
const OUTPUT_DIR = './output';
const OUTPUT_FILE = 'output.js';

export class DocumentationCrawler {
  constructor(apiKey) {
    this.apiKey = apiKey;
    this.axiosInstance = axios.create({
      baseURL: FIRECRAWL_BASE_URL,
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json'
      },
      timeout: 300000 // 5 minutes timeout
    });
  }

  async startCrawl(url) {
    console.log(`üöÄ Starting crawl for: ${url}`);
    
    try {
      const response = await this.axiosInstance.post('/crawl', {
        url: url,
        limit: 50, // Limit pages to prevent overwhelming
        scrapeOptions: {
          formats: ['markdown', 'html'],
          onlyMainContent: true
        },
        allowBackwardLinks: false,
        allowExternalLinks: false
      });

      console.log('‚úÖ Crawl initiated successfully');
      console.log(`üìã Crawl ID: ${response.data.id}`);
      
      return response.data.id;
    } catch (error) {
      console.error('‚ùå Error starting crawl:', error.message);
      if (error.response?.data) {
        console.error('Error details:', error.response.data);
      }
      throw error;
    }
  }

  async checkCrawlStatus(crawlId) {
    try {
      const response = await this.axiosInstance.get(`/crawl/${crawlId}`);
      return response.data;
    } catch (error) {
      console.error('‚ùå Error checking crawl status:', error.message);
      throw error;
    }
  }

  async waitForCrawlCompletion(crawlId) {
    console.log('‚è≥ Waiting for crawl to complete...');
    
    while (true) {
      const status = await this.checkCrawlStatus(crawlId);
      
      console.log(`üìä Status: ${status.status} | Progress: ${status.completed}/${status.total} pages`);
      
      if (status.status === 'completed') {
        console.log('‚úÖ Crawl completed successfully!');
        return status;
      } else if (status.status === 'failed') {
        throw new Error(`Crawl failed: ${status.error || 'Unknown error'}`);
      }
      
      // Wait 5 seconds before checking again
      await new Promise(resolve => setTimeout(resolve, 5000));
    }
  }

  async saveToFile(data) {
    try {
      // Ensure output directory exists
      await fs.mkdir(OUTPUT_DIR, { recursive: true });
      
      // Create the output file content
      const fileContent = `// Generated by DocMCP Prototype
// Crawl completed at: ${new Date().toISOString()}
// Source URL: ${DOCUMENTATION_URL}

export const firecrawlOutput = ${JSON.stringify(data, null, 2)};
`;

      const outputPath = path.join(OUTPUT_DIR, OUTPUT_FILE);
      await fs.writeFile(outputPath, fileContent, 'utf8');
      
      console.log(`üíæ Raw crawl data saved to: ${outputPath}`);
      console.log(`üìä Total pages crawled: ${data.data?.length || 0}`);
      
    } catch (error) {
      console.error('‚ùå Error saving file:', error.message);
      throw error;
    }
  }
}

async function main() {
  console.log('üî• DocMCP Prototype - Firecrawl Documentation Crawler');
  console.log('=' .repeat(50));
  
  if (!FIRECRAWL_API_KEY) {
    console.error('‚ùå FIRECRAWL_API_KEY not found in environment variables');
    process.exit(1);
  }

  const crawler = new DocumentationCrawler(FIRECRAWL_API_KEY);
  
  try {
    // Start the crawl
    const crawlId = await crawler.startCrawl(DOCUMENTATION_URL);
    
    // Wait for completion and get results
    const result = await crawler.waitForCrawlCompletion(crawlId);
    
    // Save raw output to file
    await crawler.saveToFile(result);
    
    console.log('üéâ Prototype completed successfully!');
    console.log(`üìÅ Check the output directory: ${OUTPUT_DIR}/${OUTPUT_FILE}`);
    
  } catch (error) {
    console.error('üí• Prototype failed:', error.message);
    process.exit(1);
  }
}

// Run the prototype only if this file is executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch(console.error);
} 